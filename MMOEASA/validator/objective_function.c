#include <string.h>
#include "data.h"

void free_Solution(struct Solution* solution) {
    for (int v = 0; v < solution->vehicles->size; v++) {
        struct Vehicle* vehicle = (struct Vehicle*)solution->vehicles->at(solution->vehicles, v);
        for (int d = 0; d < vehicle->destinations->size; d++) {
            struct Destination* destination = (struct Destination*)vehicle->destinations->at(vehicle->destinations, d);

            free(destination->node);
            free(destination);
        }
        vehicle->destinations->clear(vehicle->destinations);
        free(vehicle);
    }
    solution->vehicles->clear(solution->vehicles);
    free(solution);
}

void objective_function(struct Solution* restrict I)
{
    float minimum_distance, maximum_distance, minimum_cargo, maximum_cargo;
    I->total_distance = 0;
    I->feasible = true;
    int v = 0;

    do {
        struct Vehicle* vehicle = (struct Vehicle*)I->vehicles->at(I->vehicles, v);
        I->total_distance += vehicle->route_distance;
        for (int d = 1; d < vehicle->destinations->size - 1; d++) {
            struct Destination* destination = (struct Destination*)vehicle->destinations->at(vehicle->destinations, d);
            if (destination->arrival_time > destination->node->due_date || vehicle->current_capacity > I->vehicle_max_capacity) {
                I->feasible = false;
                I->total_distance = INFINITY;
                I->distance_unbalance = INFINITY;
                I->cargo_unbalance = INFINITY;
                break;
            }
        }

        v++;
    } while(v < I->vehicles->size && I->feasible);

    if (I->feasible) {
        minimum_distance = INFINITY;
        maximum_distance = 0;
        minimum_cargo = INFINITY;
        maximum_cargo = 0;

        for (v = 0; v < I->vehicles->size; v++) {
            struct Vehicle* vehicle = (struct Vehicle*)I->vehicles->at(I->vehicles, v);
            if (vehicle->destinations->size >= 1) {
                if(vehicle->route_distance < minimum_distance)
                    minimum_distance = vehicle->route_distance;
                if(vehicle->route_distance > maximum_distance)
                    maximum_distance= vehicle->route_distance;
                if(vehicle->current_capacity < minimum_cargo)
                    minimum_cargo = vehicle->current_capacity;
                if(vehicle->current_capacity > maximum_cargo)
                    maximum_cargo = vehicle->current_capacity;
            }
        }

        I->distance_unbalance = maximum_distance - minimum_distance;
        I->cargo_unbalance = maximum_cargo - minimum_cargo;
    }
}

void output_objectives(const char* restrict formula_origin, struct Solution* restrict solution) {
    printf("%s's objective function:\n - feasible: %s\n - objectives:\n    - total distance = %f\n    - distance_unbalance = %f\n    - cargo_unbalance = %f\n", formula_origin, solution->feasible ? "true" : "false", solution->total_distance, solution->distance_unbalance, solution->cargo_unbalance);
}

int main(int argc, char** argv) {
    char* filename = argc > 1 ? argv[1] : NULL; // "read_csv" can accept a null filename as it will default to "solution.csv" if this is so
    struct Solution* solution = read_csv(.file=filename);

    if (solution) {
        output_objectives("Python script", solution);
        printf("\n");
        
        objective_function(solution);

        output_objectives("Original MMOEASA code", solution);
        free_Solution(solution);
    }
    else
        printf("(!) function \"read_csv\" returned NULL; is the file \"%s\" present and was it generated by the MMOEASA algorithm?", filename ? filename : "solution.csv");
    
    return 0;
}